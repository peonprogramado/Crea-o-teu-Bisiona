<!DOCTYPE html>
<html>
<head>
    <title>Debug Shader5</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        #canvas { border: 1px solid #000; }
        .info { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Debug Shader5 - Efecto Puro</h1>
    <div class="info">Este test muestra solo el efecto shader5 sin condiciones</div>
    <div class="controls">
        <button onclick="setColor('#000000')">Negro (Azules)</button>
        <button onclick="setColor('#ffffff')">Blanco (Blancos)</button>
        <button onclick="setColor('#2B43FF')">Azul (Azules)</button>
        <button onclick="setColor('original')">Original</button>
    </div>
    <canvas id="canvas" width="400" height="400"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Funciones de ruido
        function random(x, y) {
            return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453123) % 1;
        }

        function noise(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const fx = x - ix;
            const fy = y - iy;
            
            const a = random(ix, iy);
            const b = random(ix + 1, iy);
            const c = random(ix, iy + 1);
            const d = random(ix + 1, iy + 1);
            
            const u = fx * fx * (3 - 2 * fx);
            const v = fy * fy * (3 - 2 * fy);
            
            return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
        }

        function noise3D(x, y, z) {
            return (noise(x + z * 0.1, y + z * 0.1) + noise(x - z * 0.1, y - z * 0.1)) * 0.5;
        }

        function mapValue(value, start1, stop1, start2, stop2) {
            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
        }

        function hsbToRgb(h, s, b) {
            let r, g, blue;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = b * (1 - s);
            const q = b * (1 - f * s);
            const t = b * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = b, g = t, blue = p; break;
                case 1: r = q, g = b, blue = p; break;
                case 2: r = p, g = b, blue = t; break;
                case 3: r = p, g = q, blue = b; break;
                case 4: r = t, g = p, blue = b; break;
                case 5: r = b, g = p, blue = q; break;
            }
            
            return { r, g, b: blue };
        }

        let currentColor = '#000000'; // Color por defecto
        
        function setColor(color) {
            currentColor = color;
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const t = Date.now() * 0.01;
            let xoff = 0;
            const stepSize = 10;
            
            for (let x = 0; x < canvas.width; x += stepSize) {
                let yoff = 0;
                for (let y = 0; y < canvas.height; y += stepSize) {
                    const noiseR = mapValue(noise3D(xoff, yoff, t), 0, 1, 0, 360);
                    const noiseG = mapValue(noise3D(xoff + 1000, yoff + 2000, t), 0, 1, 0, 100);
                    const noiseB = mapValue(noise3D(xoff + 3000, yoff + 5000, t), 0, 1, 0, 100);
                    const a = mapValue(noise3D(xoff + 5000, yoff + 7000, t), 0, 1, 0, 100);
                    
                    let finalColor;
                    
                    // Adaptar colores segÃºn el color del SVG
                    if (currentColor === '#ffffff') {
                        // SVG blanco -> colores blancos/grises claros
                        const intensity = noiseG / 100;
                        const variation = (noiseR / 360) * 0.3;
                        const baseValue = 0.7 + intensity * 0.3 + variation;
                        finalColor = {
                            r: baseValue,
                            g: baseValue,
                            b: baseValue
                        };
                    } else if (currentColor === '#000000' || currentColor === '#2B43FF') {
                        // SVG negro o azul -> colores azules
                        const hueBase = 220;
                        const hueVariation = (noiseR / 360) * 60 - 30;
                        const finalHue = (hueBase + hueVariation) / 360;
                        const saturation = 0.6 + (noiseG / 100) * 0.4;
                        const brightness = 0.4 + (noiseB / 100) * 0.6;
                        
                        finalColor = hsbToRgb(finalHue, saturation, brightness);
                    } else {
                        // Original
                        finalColor = hsbToRgb(noiseR / 360, noiseG / 100, noiseB / 100);
                    }
                    
                    ctx.globalAlpha = a / 100;
                    ctx.fillStyle = `rgb(${Math.floor(finalColor.r * 255)}, ${Math.floor(finalColor.g * 255)}, ${Math.floor(finalColor.b * 255)})`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, stepSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    yoff += 0.1;
                }
                xoff += 0.1;
            }
            
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
